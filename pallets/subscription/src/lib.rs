#![cfg_attr(not(feature = "std"), no_std)]

//* Subscription Model based Payment System */
#[cfg(test)]
mod mock;
#[cfg(test)]
mod tests;
#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

pub use pallet::*;
use codec::{Decode, Encode, HasCompact};
use frame_support::{pallet_prelude::*, ensure, storage::child, PalletId,
	traits::{Currency, ExistenceRequirement, Get, ReservableCurrency, WithdrawReasons, UnixTime},
	sp_runtime::{traits::{AccountIdConversion, AtLeast32BitUnsigned, Saturating, Zero, Hash}, ArithmeticError,
	sp_std::prelude::*
	}
};
use scale_info::TypeInfo;

//	An index of a Payment Sytem 
pub type PaymentIndex = u32;

// 	Identify the fund created by the owner
#[derive(Encode, Decode, Clone, PartialEq, Eq, MaxEncodedLen, RuntimeDebug, TypeInfo)]
pub struct PaymentInfo<AccountId, Balance, BlockNumber> { 
	//	The account that will receive the payments after the agreed contract has finsihed 
	owner: AccountId,
	//	The minimum deposit required to subcribe to become a member
	required_deposit: Balance,
	//	The total amount of deposit generated by the service/ product
	total_deposit: Balance,
	//	Block Number at which the payouts begins  
	begin: BlockNumber,
	//	Total number of blocks over which the payout is spread
	duration: BlockNumber
}

//	Information about members
#[derive(Encode, Decode, Clone, PartialEq, Eq, MaxEncodedLen, RuntimeDebug, TypeInfo)]
pub struct MemberDetails<BlockNumber> {
	//	First Day of Payment 
	begin : BlockNumber,
	//	When to get revoked access to this extrinsic calls 
	duration: BlockNumber,
}
//*  */
#[frame_support::pallet]
pub mod pallet {
	use super::*;
	use frame_system::{pallet_prelude::*, ensure_signed};
	use frame_system::pallet_prelude::*;
	
	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	pub struct Pallet<T>(_);
	
	/// Configure the pallet by specifying the parameters and types on which it depends.
	#[pallet::config]
	pub trait Config: frame_system::Config {
		//	The units in which re record balances 
		type Balance: Member + Parameter + AtLeast32BitUnsigned + Default + Copy + MaybeSerializeDeserialize + MaxEncodedLen + TypeInfo;
		
		/// Because this pallet emits events, it depends on the runtime's definition of an event.
		type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
		
		//	The minimum payment per member upon each agreed payment date 
		type MinPayment: Get<BalanceOf<Self>>;
		
		//	Recurring payments accumulated to the owner 
		type TotalPayment: Get<BalanceOf<Self>>;
		
		//	The currency that this fund accepts
		type Currency: Currency<Self::AccountId>;
		
		//	Type to get Time on chain 
		type TimeProvider: UnixTime;
		
		// 	Set the duration for Membership
		#[pallet::constant]
		type MaxPaymentDuration: Get<u64>;

		//	Membership duration per member
		#[pallet::constant]
		type MaxLockDuration: Get<u64>;
		
		//	'PalletId' for the Subscription Pallet 
		#[pallet::constant]
		type PalletId: Get<PalletId>;

	}
	type PaymentIndex = u32;
	type AccountIdOf<T> = <T as frame_system::Config>::AccountId;
	type BalanceOf<T> = <<T as Config>::Currency as Currency<AccountIdOf<T>>>::Balance;
	//	Negative Imbalance: The total supply of tokens is less than the toal issuance in the balances module 
	//	I.E. If oyu mint a token without changing anyone else's balance or decrease someone's balance without increasing a balance somewhere elese 
	type NegativeImbalanceOf<T> = <<T as Config>::Currency as Currency<AccountIdOf<T>>>::NegativeImbalance;
	type PaymentInfoOf<T> = PaymentInfo<AccountIdOf<T>, BalanceOf<T>, <T as frame_system::Config>::BlockNumber>;

	//	Store PaymentInfo associated with its Id 	
	#[pallet::storage]
	#[pallet::getter(fn payment_info)]
	pub type PaymentSystems<T> = StorageMap<
		_,
		Blake2_128Concat,
		PaymentIndex,
		PaymentInfoOf<T>,
		OptionQuery
	>;
	#[pallet::storage]
	#[pallet::getter(fn payment_id)]
	pub type PaymentCount<T> = StorageValue<_, PaymentIndex, ValueQuery>;

	// Pallets use events to inform users when important changes are made.
	// https://substrate.dev/docs/en/knowledgebase/runtime/events
	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		//	A payment system has been made [id, creator]
		Created { 
			id: PaymentIndex,
			owner: T::AccountId, 
		},
		SubscriptionMade {
			index: PaymentIndex,
			supporter: AccountIdOf<T>,
			balance: BalanceOf<T>,
		}

	}

	// Errors inform users that something went wrong.
	#[pallet::error]
	pub enum Error<T> {
		InvalidIndex,
		InUse,
		EndTooEarly,
		InsufficientFund,
	}

	// Dispatchable functions allows users to interact with the pallet and invoke state changes.
	// These functions materialize as "extrinsics", which are often compared to transactions.
	// Dispatchable functions must be annotated with a weight and must return a DispatchResult.
	#[pallet::call]
	impl<T: Config> Pallet<T> {
		#[pallet::weight(10_000)]
		pub fn create_payment_system(
			origin: OriginFor<T>, 
			#[pallet::compact] min_payment: BalanceOf<T>,
			#[pallet::compact] duration: T::BlockNumber
		) -> DispatchResult { 
			let creator = ensure_signed(origin)?;

			let current_block = frame_system::Pallet::<T>::block_number();
			let deposit = T::TotalPayment::get();
			ensure!(duration > current_block, Error::<T>::EndTooEarly);
		
			let payment_info = PaymentInfo { 
				owner: creator.clone(), 
				required_deposit: min_payment, 
				total_deposit: Zero::zero(),
				begin: current_block,
				duration,
			};
			let imbalance = T::Currency::withdraw(
				&creator, 
				deposit, 
				WithdrawReasons::TRANSFER,
				ExistenceRequirement::AllowDeath
			)?;
			let payment_index = Self::next_payment_id()?;
			T::Currency::resolve_creating(
				&Self::fund_account_id(payment_index),
				imbalance
			);
			PaymentSystems::<T>::insert(
				payment_index,
				payment_info
			);
			Self::deposit_event(Event::Created { 
				id: payment_index,
				owner: creator.clone()
			});

			Ok(())
		}
		//	Contribute to the payment system. This will transfer some balance over to fund the payment requirement
		//	Once subscribed, the users will be part of a membershp
		#[pallet::weight(10_000)]
		pub fn subscribe_payment(
			origin: OriginFor<T>,
			#[pallet::compact] id: PaymentIndex,
			#[pallet::compact] payment: BalanceOf<T>,
		) -> DispatchResultWithPostInfo { 
			let supporter = ensure_signed(origin)?;
			
			ensure!(payment >= T::MinPayment::get(), Error::<T>::InsufficientFund);
	
			//	Access the payment info through payment id 
			//	add payment to the total_deposit
			let mut payment_info = PaymentSystems::<T>::get(&id);
			//	Transfer funds to the associated funds 
			T::Currency::transfer(
				&supporter,
				&Self::fund_account_id(id),
				payment, 
				ExistenceRequirement::AllowDeath
			)?;
			payment_info.total_deposit = payment_info.total_deposit.checked_add(&payment).ok_or(Error::<T>::Overflow)?;
			
			let payment_made = Self::contribution_get(id, supporter);
			let payment_made = payment_made.saturating_add(payment)
			//	Record contribution in the assosciated child trie 
			Self::contribution_put(id, supporter, payment_made);
			
			Self::deposit_event(Event::SubscriptionMade {
				index: id, 
				supporter
				balance: payment,
			});

			Ok(().into())
		}	
	}
	impl<T: Config> Pallet<T> { 
		//	This is where recurring payments are paid into 
		pub fn fund_account_id(idx: PaymentIndex) -> T::AccountId { 
			T::PalletId::get().into_sub_account(idx)
		}
		//	Track Payment Index
		fn next_payment_id() -> Result<u32, DispatchError> {
			PaymentCount::<T>::try_mutate(|index| -> Result<u32, DispatchError> {
				let current_id = *index;
				*index = index.checked_add(1).ok_or(ArithmeticError::Overflow)?;
				Ok(current_id)
			})
		}
		// 	Function to find the id associated with the fund id (child trie)
		//	Each fund stores information about it ***contributors and their ***contributions in a child trie 
		
		//	This helper function calculates the id of the associate child trie 
		pub fn id_from_index(
			index: PaymentIndex
		) -> child::ChildInfo { 
			let mut buf = Vec::new();
			buf.extend_from_slice(b"payment");
			buf.extend_from_slice(&index.to_le_bytes()[..]);

			child::ChildInfo::new_default(T::Hashing::hash(&buf[..]).as_ref())
		}
		//	Put Payment under a key: user account 
		pub fn contribution_put(
			index: PaymentIndex, 
			who: &T::AccountId, 
			balance: &BalanceOf<T>
		) {
			let id = Self::id_from_index(index);
			who.using_encoded(|b| child::put(&id, b, &balance));
		}
		//	Get the value paid by the user 
		pub fn contribution_get(
			index: PaymentIndex, 
			who: &T::AccountId
		) -> BalanceOf<T> {
			let id = Self::id_from_index(index);
			who.using_encoded(|b| child::get_or_default::<BalanceOf<T>>(&id, b))
		}
		pub fn crowdfund_kill(index: PaymentIndex) {
			let id = Self::id_from_index(index);
			// The None here means we aren't setting a limit to how many keys to delete.
			// Limiting can be useful, but is beyond the scope of this recipe. For more info, see
			// https://crates.parity.io/frame_support/storage/child/fn.kill_storage.html
			child::kill_storage(&id, None);
		}
	}
}
